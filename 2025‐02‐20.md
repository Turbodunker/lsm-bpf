# What was done?
# TODO
- [x] Write out the exact definition of a "building block" - (Comment: this is now pattern, building block is too long)
- [x] Create a "block directory" building block and use above definition - It should block all READ operations on one or more directories
- [x] Identify and create a systematic process for evaluation this given building block - symlink, hardlink, re-mounts, directory renames/move etc.
- [ ] If time, attempt to add identification for process and do the same as above (Comment: I assumed this was optimistic, as this is a pattern on it's own, and the definition is still not set in stone.)
- [ ] Come up with more interesting use-cases that can create new and potentially use previous building blocks - (Comment: Have found some promising material, but did not have time for this due to continued illness)



* Tried to write a definition of a building block, ie. what is required and what is optional for a building block to exist.
* Tried to follow the Tetragon approach for file monitoring, ie. don't use syscalls, but kernel_functions instead, and use inodes instead of path traversel. Keep a tracking list of inodes to handle creation, moving and deletion of inodes. 
* There are two possible approaches as I see it: path traversal and a lot of string manipulation OR inode checking. I believe inode approach is superior, as the other approach cannot work for hardlinks. 
* But what if the file/directory ie. the inode is deleted or new inodes are introduced?
* Solution: Place bpf programs at the following lsm inode hooks: inode_create, inode_mkdir, inode_rmdir, 

1. Cat file in directory or ls content of directory or subdirectories - Tested and works
2. Create new directory or file in secret and read from that - Tested and works
```
echo "this should still be secret" > secret/newfile.txt                                                                                                                                                                                                            cat secret/newfile.txt                                 
cat: secret/newfile.txt: Permission denied
```
```
mkdir secret/newdir
ls secret/newdir 
ls: reading directory 'secret/newdir': Permission denied
```
3. Write and execute files - Tested and works. Doing ```echo "123" >> secret/flag.txt > password.txt``` from outside secret will still append 123 to the flag.txt, but only write 123 to password.txt. Neither evilcat or helloworld(inside secret/) can be executed. 
3. Symbolic + Hardlinks(previously existing and new ones) - Tested and works
4. chroot - Tested with /bin/ls only, but works for that
5. bind mounts - ```sudo mount --bind $HOME/secret $HOME/test``` we get the following:
```
ls test                   
ls: reading directory 'test': Permission denied
```
```
cat test/flag.txt  
cat: test/flag.txt: Permission denied
```
```
cat test/subsecret/notsecret.txt          
you should still be able to read this
```
7. aliases - 
```
omgpleasedont='ls secret'                                                                                                                                                                                                            
omgpleasedont
ls: reading directory 'secret': Permission denied                                                                                                                                                                                                            

alias omgpleasedont='cat secret/flag.txt'                                                                                                                                                                                                          
omgpleasedont
cat: secret/flag.txt: Permission denied
```
8. special files, like pipes. This also works if cat /path/to/pipe is called prior to the LSM-BPF program being loaded.
```
mkfifo secret/mypipe                                                                                                                                                                                                           
echo "Hello?" > secret/mypipe & cat secret/mypipe
[1] 32847
cat: secret/mypipe: Permission denied
[1]  + done       echo "Hello?" > secret/mypipe
```                                                
9. memory mapped files - currently does work for mmaps initiated after LSM BPF program loaded, but not for programs that were already mmapped.
# What is left?
Ideally user should just give a list of paths/some json/yaml thing
TODO: make function that takes a list of paths and returns a list of inode numbers
TODO: make a function that given a list of paths can return all inode numbers of the content for 1-level 
TODO: remove map entries when items are deleted. Need to find a good hook for this. Considering file_free_security.
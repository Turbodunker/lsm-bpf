# What was done?
* Tried to write a definition of a building block, ie. what is required and what is optional for a building block to exist.
* Tried to follow the Tetragon approach for file monitoring, ie. don't use syscalls, but kernel_functions instead, and use inodes instead of path traversel. Keep a tracking list of inodes to handle creation, moving and deletion of inodes. 
* There are two possible approaches as I see it: path traversal and a lot of string manipulation OR inode checking. I believe inode approach is superior, as the other approach cannot work for hardlinks. 
* But what if the file/directory ie. the inode is deleted or new inodes are introduced?
* Solution: Place bpf programs at the following lsm inode hooks: inode_create, inode_mkdir, inode_rmdir, 

1. Cat file in directory or ls content of directory or subdirectories - Tested and works
2. Create new directory or file in secret and read from that - Tested and works
```
echo "this should still be secret" > secret/newfile.txt                                                                                                                                                                                                            cat secret/newfile.txt                                 
cat: secret/newfile.txt: Permission denied
```
```
mkdir secret/newdir
ls secret/newdir 
ls: reading directory 'secret/newdir': Permission denied
```
3. Write and execute files - Tested and works. Doing ```echo "123" >> secret/flag.txt > password.txt``` from outside secret will still append 123 to the flag.txt, but only write 123 to password.txt. Neither evilcat or helloworld(inside secret/) can be executed. 
3. Symbolic + Hardlinks(previously existing and new ones) - Tested and works
4. chroot - Tested with /bin/ls only, but works for that
5. bind mounts - ```sudo mount --bind $HOME/secret $HOME/test``` we get the following:
```
ls test                   
ls: reading directory 'test': Permission denied
```
```
cat test/flag.txt  
cat: test/flag.txt: Permission denied
```
```
cat test/subsecret/notsecret.txt          
you should still be able to read this
```
6. aliases - 
```
└─$ alias omgpleasedont='ls secret'
                                                                                                                                                                                                            
┌──(mblomqvist㉿mblomqvist)-[~]
└─$ omgpleasedont
ls: reading directory 'secret': Permission denied
                                                                                                                                                                                                            
┌──(mblomqvist㉿mblomqvist)-[~]
└─$ alias omgpleasedont='cat secret/flag.txt'
                                                                                                                                                                                                            
┌──(mblomqvist㉿mblomqvist)-[~]
└─$ omgpleasedont
cat: secret/flag.txt: Permission denied
```
7. special files, like pipes? - untested, but most likely works
8. memory mapped files - untested and most likely won't work
# What is left?
Ideally user should just give a list of paths/some json/yaml thing
TODO: make function that takes a list of paths and returns a list of inode numbers
TODO: make a function that given a list of paths can return all inode numbers of the content for 1-level 
TODO: remove map entries when items are deleted. Need to find a good hook for this. Considering file_free_security.